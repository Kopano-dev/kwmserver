/*
 * Copyright 2020 Kopano and its licensors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package rtm

import (
	"encoding/json"
	"strings"
	"time"

	"stash.kopano.io/kgol/rndm"

	api "stash.kopano.io/kwm/kwmserver/signaling/api-v1"
	"stash.kopano.io/kwm/kwmserver/signaling/connection"
)

// minimalChatsPayloadVersion defines the Chats payload minimal compatibility
// level of the servers chats payload data as received by clients.
const minimalChatsPayloadVersion uint64 = 0

// currentWebRTCPayloadVersion defines the Chats payload version sent with
// payloads generated by the server. If possible, this should be kept in sync
// with kwmjs.
const currentChatsPayloadVersion uint64 = 20201201

func (m *Manager) onChats(c *connection.Connection, msg *api.RTMTypeChats) error {
	processErr := m.processChatsMessage(c, msg)

	// Error postprocesing.
	switch err := processErr.(type) {
	case *api.RTMTypeError:
		switch err.ErrorData.Code {
		case api.RTMErrorIDNoSessionForUser:
			// Ignore unknown session errors here to avoid leaking this info
			// to clients.
			return nil
		}
	}

	return processErr
}

func (m *Manager) validateRestrictedChatsMessage(c *connection.Connection, msg *api.RTMTypeChats, ur *userRecord) (*api.AdminAuthToken, error) {
	return nil, nil
}

func (m *Manager) processChatsMessage(c *connection.Connection, msg *api.RTMTypeChats) error {
	if msg.Version < minimalChatsPayloadVersion {
		return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "outdated Chats payload version", msg.ID)
	}

	// Fech user record for connection.
	bound := c.Bound()
	ur, _ := bound.(*userRecord)
	_, err := m.validateRestrictedChatsMessage(c, msg, ur)
	if err != nil {
		return api.NewRTMTypeError(api.RTMErrorIDAccessRestricted, err.Error(), msg.ID)
	}

	switch msg.Subtype {
	case api.RTMSubtypeNameChatsMessage:
		// Connection must have a user.
		if ur == nil {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "connection has no user", msg.ID)
		}
		// Channel must not be empty.
		if msg.Channel == "" || msg.Data == nil {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "channel or data is empty", msg.ID)
		}

		// Get channel
		record, ok := m.channels.Get(msg.Channel)
		if !ok {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "channel not found", msg.ID)
		}
		channel := record.(*channelRecord).channel

		// Receiving connection must be in channel.
		if cc, _ := channel.Get(ur.id); cc != c {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "connection not in channel", msg.ID)
		}

		// Check extra data.
		var extra *api.RTMDataChatsMessage
		err = json.Unmarshal(msg.Data, &extra)
		if err != nil {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message data parse error", msg.ID)
		}

		// Message sender must be empty.
		if extra.Sender != "" {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message sender must be empty", msg.ID)
		}
		// Message target must be empty (means everyone in the channel)
		if extra.Target != "" {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message target must be empty", msg.ID)
		}

		switch extra.Kind {
		case api.RTMChatsMessageKindMessageUserText:
			// Normal user generated text message.
			extra.Text = strings.TrimSpace(extra.Text)
			if extra.Text == "" {
				return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message text is empty", msg.ID)
			}
			if extra.Extra != nil {
				return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message contains unexpected extra data", msg.ID)
			}
			extra.RichText = strings.TrimSpace(extra.RichText)

		default:
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "unknown message kind", msg.ID)
		}

		// Generate new message ID.
		messageID := rndm.GenerateRandomString(12)

		// Set meta data.
		extra.TS = time.Now().Unix()
		extra.ID = messageID
		extra.Sender = ur.id

		// Create profile.
		profile := &api.RTMDataProfile{}
		if ur.auth != nil {
			profile.Name = ur.auth.Name()
		}

		// Encode payload (only once, same message for everyone).
		message, err := json.MarshalIndent(extra, "", "\t")
		if err != nil {
			m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats message")
			return nil
		}
		payload, err := json.MarshalIndent(&api.RTMTypeChats{
			RTMTypeSubtypeEnvelope: &api.RTMTypeSubtypeEnvelope{
				Type:    api.RTMTypeNameChats,
				Subtype: api.RTMSubtypeNameChatsMessage,
			},
			Channel: channel.id,
			Profile: profile,
			Data:    message,
			Version: currentChatsPayloadVersion,
		}, "", "\t")
		if err != nil {
			m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats message data")
			return nil
		}

		// Scope with lock, to ensure chat message order per channel.
		err = func() error {
			channel.namedMutexLock(channelMutexChats)
			defer channel.namedMutexUnlock(channelMutexChats)

			// Send to self to let sender know id of the new message.
			sendErr := c.Send(&api.RTMTypeChatsReply{
				RTMTypeSubtypeEnvelopeReply: &api.RTMTypeSubtypeEnvelopeReply{
					Type:    api.RTMTypeNameChats,
					Subtype: api.RTMSubtypeNameChatsMessage,
					ReplyTo: msg.ID,
				},
				Channel: channel.id,
				Data:    message,
				Version: currentChatsPayloadVersion,
			})
			if sendErr != nil {
				m.logger.WithError(sendErr).WithField("channel", channel.id).Errorln("failed to send channel chats message reply to sender")
				return sendErr
			}

			// Loop through channel connections, sending out payload.
			_, connections := channel.Connections()
			for _, connection := range connections {
				if connection == c {
					// Skip sending message to sender (self).
					continue
				}
				err = connection.RawSend(payload)
				if err != nil {
					connection.Logger().WithError(err).WithField("channel", channel.id).Errorln("failed to send channel chats message to connection")
				}
			}

			return nil
		}()
		if err != nil {
			return err
		}

		// Send to self for delivery report to sender.
		extra = &api.RTMDataChatsMessage{
			ID:   messageID,
			Kind: api.RTMChatsMessageKindMessageQueued,
		}
		message, err = json.MarshalIndent(extra, "", "\t")
		if err != nil {
			m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats delivery system message")
			return nil
		}
		err = c.Send(&api.RTMTypeChats{
			RTMTypeSubtypeEnvelope: &api.RTMTypeSubtypeEnvelope{
				Type:    api.RTMTypeNameChats,
				Subtype: api.RTMSubtypeNameChatsSystem,
			},
			Channel: channel.id,
			Data:    message,
			Version: currentChatsPayloadVersion,
		})
		if err != nil {
			m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to send channel chats delivery system message to sender")
		}

	default:
		return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "unknown subtype", msg.ID)
	}

	return nil
}

func (m *Manager) emitChannelChatsAddOrRemove(c *connection.Connection, channel *Channel, op ChannelOp, id string) error {
	// Fech user record for connection.
	bound := c.Bound()
	ur, _ := bound.(*userRecord)

	// Create profile.
	profile := &api.RTMDataProfile{}
	displayName := ""
	if ur.auth != nil {
		displayName = ur.auth.Name()
		profile.Name = displayName
	} else {
		displayName = "Unknown user"
	}

	extra := &api.RTMDataChatsMessage{
		ID:     rndm.GenerateRandomString(12),
		Kind:   api.RTMChatsMessageKindSystemText,
		TS:     time.Now().Unix(),
		Sender: id,
	}

	switch op {
	case ChannelOpAdd:
		extra.Text = displayName + " has joined the meeting."
		extra.Extra = map[string]interface{}{
			"id": "joined",
		}
	case ChannelOpRemove:
		extra.Text = displayName + " has left the meeting."
		extra.Extra = map[string]interface{}{
			"id": "left",
		}
	}

	// Encode payload (only once, same message for everyone).
	message, err := json.MarshalIndent(extra, "", "\t")
	if err != nil {
		m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats system join/left message")
		return err
	}
	payload, err := json.MarshalIndent(&api.RTMTypeChats{
		RTMTypeSubtypeEnvelope: &api.RTMTypeSubtypeEnvelope{
			Type:    api.RTMTypeNameChats,
			Subtype: api.RTMSubtypeNameChatsSystem,
		},
		Channel: channel.id,
		Profile: profile,
		Data:    message,
		Version: currentChatsPayloadVersion,
	}, "", "\t")
	if err != nil {
		m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats system join/left data")
		return err
	}

	err = func() error {
		channel.namedMutexLock(channelMutexChats)
		defer channel.namedMutexUnlock(channelMutexChats)

		// Loop through channel connections, sending out payload.
		_, connections := channel.Connections()
		for _, connection := range connections {
			if connection == c {
				// Skip sending message to sender (self).
				continue
			}
			err = connection.RawSend(payload)
			if err != nil {
				connection.Logger().WithError(err).WithField("channel", channel.id).Errorln("failed to send channel chats system join/left to connection")
			}
		}

		return nil
	}()
	if err != nil {
		return err
	}

	return nil
}
