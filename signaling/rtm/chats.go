/*
 * Copyright 2020 Kopano and its licensors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package rtm

import (
	"encoding/json"
	"strings"
	"time"

	"stash.kopano.io/kgol/rndm"

	api "stash.kopano.io/kwm/kwmserver/signaling/api-v1"
	"stash.kopano.io/kwm/kwmserver/signaling/connection"
)

// minimalChatsPayloadVersion defines the Chats payload minimal compatibility
// level of the servers chats payload data as received by clients.
const minimalChatsPayloadVersion uint64 = 0

// currentWebRTCPayloadVersion defines the Chats payload version sent with
// payloads generated by the server. If possible, this should be kept in sync
// with kwmjs.
const currentChatsPayloadVersion uint64 = 20201201

func (m *Manager) onChats(c *connection.Connection, msg *api.RTMTypeChats) error {
	processErr := m.processChatsMessage(c, msg)

	// Error postprocesing.
	switch err := processErr.(type) {
	case *api.RTMTypeError:
		switch err.ErrorData.Code {
		case api.RTMErrorIDNoSessionForUser:
			// Ignore unknown session errors here to avoid leaking this info
			// to clients.
			return nil
		}
	}

	return processErr
}

func (m *Manager) validateRestrictedChatsMessage(c *connection.Connection, msg *api.RTMTypeChats, ur *userRecord) (*api.AdminAuthToken, error) {
	return nil, nil
}

func (m *Manager) processChatsMessage(c *connection.Connection, msg *api.RTMTypeChats) error {
	if msg.Version < minimalChatsPayloadVersion {
		return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "outdated Chats payload version", msg.ID)
	}

	// Fech user record for connection.
	bound := c.Bound()
	ur, _ := bound.(*userRecord)
	_, err := m.validateRestrictedChatsMessage(c, msg, ur)
	if err != nil {
		return api.NewRTMTypeError(api.RTMErrorIDAccessRestricted, err.Error(), msg.ID)
	}

	switch msg.Subtype {
	case api.RTMSubtypeNameChatsMessage:
		// Connection must have a user.
		if ur == nil {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "connection has no user", msg.ID)
		}
		// Channel must not be empty.
		if msg.Channel == "" || msg.Data == nil {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "channel or data is empty", msg.ID)
		}

		// Get channel
		record, ok := m.channels.Get(msg.Channel)
		if !ok {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "channel not found", msg.ID)
		}
		channel := record.(*channelRecord).channel

		// Receiving connection must be in channel.
		if cc, _ := channel.Get(ur.id); cc != c {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "connection not in channel", msg.ID)
		}

		// Check extra data.
		var extra *api.RTMDataChatsMessage
		err = json.Unmarshal(msg.Data, &extra)
		if err != nil {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message data parse error", msg.ID)
		}

		// Message sender must be empty.
		if extra.Sender != "" {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message sender must be empty", msg.ID)
		}
		// Message target must be empty (means everyone in the channel)
		if extra.Target != "" {
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message target must be empty", msg.ID)
		}

		switch extra.Kind {
		case "":
			// Normal user generated text message.
			extra.Text = strings.TrimSpace(extra.Text)
			if extra.Text == "" {
				return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "message text is empty", msg.ID)
			}
			extra.RichText = strings.TrimSpace(extra.RichText)

		default:
			return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "unknown message kind", msg.ID)
		}

		extra.TS = time.Now().Unix()
		extra.ID = rndm.GenerateRandomString(12)
		extra.Sender = ur.id

		// Create profile.
		profile := &api.RTMDataProfile{}
		if ur.auth != nil {
			profile.Name = ur.auth.Name()
		}

		message, err := json.MarshalIndent(extra, "", "\t")
		if err != nil {
			m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats message")
			return nil
		}
		payload, err := json.MarshalIndent(&api.RTMTypeChats{
			RTMTypeSubtypeEnvelope: &api.RTMTypeSubtypeEnvelope{
				Type:    api.RTMTypeNameChats,
				Subtype: api.RTMSubtypeNameChatsMessage,
			},
			Channel: channel.id,
			Profile: profile,
			Data:    message,
			Version: currentChatsPayloadVersion,
		}, "", "\t")
		if err != nil {
			m.logger.WithError(err).WithField("channel", channel.id).Errorln("failed to encode channel chats message data")
			return nil
		}

		// TODO(longsleep): Ensure chat message order per channel.

		// Send to self to let sender know id.
		c.Send(&api.RTMTypeChatsReply{
			RTMTypeSubtypeEnvelopeReply: &api.RTMTypeSubtypeEnvelopeReply{
				Type:    api.RTMTypeNameChats,
				Subtype: api.RTMSubtypeNameChatsMessage,
				ReplyTo: msg.ID,
			},
			Channel: channel.id,
			Data:    message,
			Version: currentChatsPayloadVersion,
		})

		_, connections := channel.Connections()
		for _, connection := range connections {
			if connection == c {
				continue
			}

			err = connection.RawSend(payload)
			if err != nil {
				connection.Logger().WithError(err).WithField("channel", channel.id).Errorln("failed to send channel chats message to connection")
			}
		}

	default:
		return api.NewRTMTypeError(api.RTMErrorIDBadMessage, "unknown subtype", msg.ID)
	}

	return nil
}
